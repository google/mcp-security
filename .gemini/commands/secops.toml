description = "Implement slash command to call MCP Tools"
prompt = """
You are implementing /slash-commands to call the available MCP Tools
"""

# SecOps entity_lookup
[[subCommands]]
name = "entity-lookup"
description = "Look up an entity (IP, domain, hash, user, etc.) in Chronicle SIEM for enrichment and historical context"
prompt = """
{% if help %}
Usage: /secops entity-lookup [OPTIONS]

Look up an entity (IP, domain, hash, user, etc.) in Chronicle SIEM for enrichment.

Provides a comprehensive summary of an entity's activity based on historical log data
within Chronicle over a specified time period. Chronicle automatically attempts to 
detect the entity type from the value provided.

Options:
  --entity-value  Value to look up (IP, domain, hash, username) [REQUIRED]
  --hours-back    Hours of historical data to consider (default: 24)
  --help          Show this help message

Examples:
  /secops entity-lookup --entity-value="192.168.1.100"           # Lookup IP address
  /secops entity-lookup --entity-value="evil.com"                # Lookup domain
  /secops entity-lookup --entity-value="user@example.com"        # Lookup user
  /secops entity-lookup --entity-value="WIN-HELIUM"              # Lookup hostname
  /secops entity-lookup --entity-value="abc123hash" --hours-back=72  # 3-day lookup

The summary includes:
- Primary entity details (type, first/last seen)
- Related entities observed interacting with the primary entity
- Associated Chronicle alerts triggered involving the entity
- Timeline summary (event/alert counts over the period)
- Prevalence information (if available)

Use this to quickly understand context and prevalence of indicators by examining SIEM log data.
{% else %}
Call the lookup_entity tool with: `lookup_entity(entity_value={{entity-value}}, hours_back={{hours-back}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "entity-value"
  required = true
  description = "Value to look up (IP address, domain name, file hash, username)"
  [[subCommands.args]]
  name = "hours-back"
  required = false
  default = "24"
  description = "Number of hours of historical data to consider for the summary"

# SecOps get_ioc_matches
[[subCommands]]
name = "ioc-matches"
description = "Get Indicators of Compromise (IoC) matches from Chronicle SIEM - retrieves malicious IPs, domains, and hashes observed in logs"
prompt = """
{% if help %}
Usage: /secops ioc-matches [OPTIONS]

Get Indicators of Compromise (IoC) matches from Chronicle SIEM.
Retrieves IoCs (e.g., malicious IPs, domains, hashes) from configured threat
intelligence feeds that have been observed matching events in Chronicle logs.

Options:
  --hours-back    Hours to look back for IoC matches (default: 24)
  --max-matches   Maximum number of IoC matches to return (default: 20)
  --help          Show this help message

Examples:
  /secops ioc-matches                          # Get IoC matches from last 24 hours
  /secops ioc-matches --hours-back 72          # Get IoC matches from last 3 days  
  /secops ioc-matches --max-matches 50         # Get up to 50 IoC matches
  /secops ioc-matches --hours-back 48 --max-matches 100

Use this to proactively identify potential threats based on IoC matches within SIEM data.
{% else %}
Call the get_ioc_matches tool with: `get_ioc_matches(hours_back={{hours-back}}, max_matches={{max-matches}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "hours-back"
  required = false
  default = "24"
  description = "Number of hours to look back for IoC matches"
  [[subCommands.args]]
  name = "max-matches"
  required = false
  default = "20"
  description = "Maximum number of IoC matches to return"

# SecOps search_security_events
[[subCommands]]
name = "search-events"
description = "Search for security events in Chronicle SIEM using natural language queries"
prompt = """
{% if help %}
Usage: /secops search-events [OPTIONS]

Search for security events in Chronicle SIEM using natural language.

Allows searching Chronicle event logs using natural language queries, which are
automatically translated into UDM queries for execution. Ideal for deep investigation
after an initial alert, case, or entity has been prioritized.

Options:
  --query         Natural language description of events to find [REQUIRED]
  --hours-back    Hours back from current time to search (default: 24)
  --max-events    Maximum number of event records to return (default: 100)
  --help          Show this help message

Examples:
  /secops search-events --query="Show network connections involving IP 10.0.0.5"
  /secops search-events --query="Find login events for user 'admin' yesterday"
  /secops search-events --query="List file modifications on host 'server1'"
  /secops search-events --query="DNS lookups to malicious.example.com" --hours-back=72
  /secops search-events --query="PowerShell execution events" --max-events=50

Query Tips:
- Use natural language to describe what you're looking for
- Specify entity types: IPs, domains, users, hosts, files
- Include time references: "yesterday", "last 6 hours", "today"
- Be specific about event types: logins, network connections, file modifications
- For email addresses, use only lowercase letters

The response includes:
- Translated UDM query used for the search
- List of matching UDM event records
- Total event count (may exceed max-events limit)

Use this to retrieve detailed UDM event logs for specific indicators or activities.
{% else %}
Call the search_security_events tool with: `search_security_events(text={{query}}, hours_back={{hours-back}}, max_events={{max-events}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "query"
  required = true
  description = "Natural language query to search for events"
  [[subCommands.args]]
  name = "hours-back"
  required = false
  default = "24"
  description = "Hours back from current time to search"
  [[subCommands.args]]
  name = "max-events"
  required = false
  default = "100"
  description = "Maximum number of event records to return"

# SecOps get_security_alerts
[[subCommands]]
name = "get-alerts"
description = "Get security alerts directly from Chronicle SIEM for monitoring and triage"
prompt = """
{% if help %}
Usage: /secops get-alerts [OPTIONS]

Get security alerts directly from Chronicle SIEM.

Retrieves a list of recent security alerts generated within Chronicle, based on
detection rules or other alert sources configured in the SIEM. Use this for direct
monitoring of SIEM alert activity and initial triage.

Options:
  --hours-back     Hours to look back for alerts (default: 24)
  --max-alerts     Maximum number of alerts to return (default: 10)
  --status-filter  Query string to filter alerts by status (default: exclude closed)
  --help           Show this help message

Examples:
  /secops get-alerts                                    # Get recent non-closed alerts
  /secops get-alerts --hours-back=72                    # Get alerts from last 3 days
  /secops get-alerts --max-alerts=25                    # Get up to 25 alerts
  /secops get-alerts --status-filter=""                 # Get all alerts (including closed)
  /secops get-alerts --hours-back=48 --max-alerts=20   # Custom time and limit

Status Filter Examples:
  feedback_summary.status != "CLOSED"                   # Exclude closed alerts (default)
  feedback_summary.status = "NEW"                       # Only new alerts
  feedback_summary.severityDisplay = "HIGH"             # Only high severity alerts

The response includes for each alert:
- Rule name that generated the alert
- Creation timestamp
- Current status (NEW, REVIEWED, CLOSED)
- Severity level
- Associated case information (if available)

Use Cases:
- Monitor for recent high-priority security events
- Get overview of current alert queue for triage
- Check for alerts that might not have corresponding cases yet
- Initial assessment before deeper investigation

Next Steps:
- Use /secops get-alert --alert-id=ID for specific alert details
- Use /secops search-events to find related raw logs
- Use /secops entity-lookup on indicators found in alerts
{% else %}
Call the get_security_alerts tool with: `get_security_alerts(hours_back={{hours-back}}, max_alerts={{max-alerts}}, status_filter={{status-filter}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "hours-back"
  required = false
  default = "24"
  description = "Hours to look back for alerts"
  [[subCommands.args]]
  name = "max-alerts"
  required = false
  default = "10"
  description = "Maximum number of alerts to return"
  [[subCommands.args]]
  name = "status-filter"
  required = false
  default = "feedback_summary.status != \"CLOSED\""
  description = "Query string to filter alerts by status"

# SecOps get_security_alert_by_id
[[subCommands]]
name = "get-alert"
description = "Get detailed information for a specific security alert by ID from Chronicle SIEM"
prompt = """
{% if help %}
Usage: /secops get-alert [OPTIONS]

Get security alert by ID directly from Chronicle SIEM.

Retrieves detailed information for a specific security alert using its unique ID.
This provides comprehensive alert details including detection information, metadata,
and associated events for deep investigation and analysis.

Options:
  --alert-id            Unique ID of the alert to retrieve [REQUIRED]
  --include-detections  Include detection details in response (default: true)
  --help                Show this help message

Examples:
  /secops get-alert --alert-id="de_12345678-1234-1234-1234-123456789012"
  /secops get-alert --alert-id="de_abcdef12-3456-7890-abcd-ef1234567890" --include-detections=false
  /secops get-alert --alert-id="de_87654321-4321-4321-4321-210987654321" --include-detections=true

Alert ID Format:
  Alert IDs typically follow the pattern: de_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
  You can get alert IDs from:
  - /secops get-alerts command output
  - Chronicle SIEM alert console
  - SOAR case management systems
  - Other security tools integrated with Chronicle

The response includes:
- Complete alert metadata and properties
- Detection rule information that triggered the alert
- Alert status, severity, and priority
- Timeline and creation information
- Associated detection details (if include-detections=true)
- Related entities and indicators
- Case association information (if available)

Use Cases:
- Deep dive investigation of a specific alert
- Gather context before updating alert status
- Extract detailed information for incident response
- Validate alert details before taking response actions
- Review detection logic and rule performance

Next Steps:
- Use /secops update-alert to modify alert status or add comments
- Use /secops search-events to find related raw event logs
- Use /secops entity-lookup on entities found in the alert
- Use /secops get-detections to see historical detections from the same rule
{% else %}
Call the get_security_alert_by_id tool with: `get_security_alert_by_id(alert_id={{alert-id}}, include_detections={{include-detections}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "alert-id"
  required = true
  description = "The unique ID of the alert to retrieve"
  [[subCommands.args]]
  name = "include-detections"
  required = false
  default = "true"
  description = "Include detection details in the response"

# SecOps do_update_security_alert
[[subCommands]]
name = "update-alert"
description = "Update security alert attributes directly in Chronicle SIEM for investigation disposition"
prompt = """
{% if help %}
Usage: /secops update-alert [OPTIONS]

Update security alert attributes directly in Chronicle SIEM.

Modifies specific fields of an existing security alert based on its ID. Use this after
investigation, triage, or automated analysis to record findings or change alert state.
At least one optional field should be provided to perform a meaningful update.

Options:
  --alert-id     Unique ID of the alert to update [REQUIRED]
  --reason       Reason for closing alert
  --priority     Alert priority level  
  --status       Alert lifecycle status
  --verdict      Investigation verdict (true/false positive)
  --severity     Severity score (0-100)
  --comment      Analyst comment (empty string clears existing)
  --root-cause   Alert root cause (empty string clears existing)
  --help         Show this help message

Valid Values:

Reason:
  REASON_UNSPECIFIED, REASON_NOT_MALICIOUS, REASON_MALICIOUS, REASON_MAINTENANCE

Priority:
  PRIORITY_UNSPECIFIED, PRIORITY_INFO, PRIORITY_LOW, PRIORITY_MEDIUM, PRIORITY_HIGH, PRIORITY_CRITICAL

Status:
  STATUS_UNSPECIFIED, NEW, REVIEWED, CLOSED, OPEN

Verdict:
  VERDICT_UNSPECIFIED, TRUE_POSITIVE, FALSE_POSITIVE

Examples:
  # Mark alert as false positive
  /secops update-alert --alert-id="de_12345" --verdict="FALSE_POSITIVE" --status="CLOSED" --comment="Benign admin activity"

  # Escalate alert priority with analysis
  /secops update-alert --alert-id="de_67890" --priority="PRIORITY_HIGH" --severity=85 --comment="Confirmed malicious activity"

  # Close alert with root cause
  /secops update-alert --alert-id="de_abcde" --status="CLOSED" --reason="REASON_NOT_MALICIOUS" --root-cause="Scheduled maintenance"

  # Add investigation notes
  /secops update-alert --alert-id="de_fghij" --comment="Investigating with IR team - potential data exfiltration"

  # Clear existing comment
  /secops update-alert --alert-id="de_klmno" --comment=""

Use Cases:
- Mark alerts as true/false positives after investigation
- Escalate or de-escalate alert priority based on impact assessment  
- Add investigation comments and findings
- Set final disposition when closing alerts
- Update severity based on additional evidence
- Record root cause analysis results

Next Steps:
- Use /secops get-alert to verify changes were applied
- Consider rule tuning if marking as false positive
- Document significant findings in external case management
- Communicate critical updates to relevant teams
{% else %}
Call the do_update_security_alert tool with: `do_update_security_alert(alert_id={{alert-id}}, reason={{reason}}, priority={{priority}}, status={{status}}, verdict={{verdict}}, severity={{severity}}, comment={{comment}}, root_cause={{root-cause}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "alert-id"
  required = true
  description = "The unique ID of the alert to update"
  [[subCommands.args]]
  name = "reason"
  required = false
  description = "Reason for closing alert"
  [[subCommands.args]]
  name = "priority"
  required = false
  description = "Alert priority level"
  [[subCommands.args]]
  name = "status"
  required = false
  description = "Alert lifecycle status"
  [[subCommands.args]]
  name = "verdict"
  required = false
  description = "Investigation verdict"
  [[subCommands.args]]
  name = "severity"
  required = false
  description = "Severity score (0-100)"
  [[subCommands.args]]
  name = "comment"
  required = false
  description = "Analyst comment"
  [[subCommands.args]]
  name = "root-cause"
  required = false
  description = "Alert root cause"

# SecOps list_security_rules
[[subCommands]]
name = "list-rules"
description = "List security detection rules configured in Chronicle SIEM"
prompt = """
{% if help %}
Usage: /secops list-rules [OPTIONS]

List security detection rules configured in Chronicle SIEM.

Retrieves the definitions of detection rules currently active or configured
within the Chronicle SIEM instance. Useful for understanding detection capabilities,
rule auditing, and identifying rules that generated specific alerts.

Options:
  --help    Show this help message

Examples:
  /secops list-rules    # List all active detection rules

The response includes:
- Rule definitions and metadata
- Rule IDs for use with other commands
- YARA-L code and logic
- Rule status and configuration

Use Cases:
- Audit the set of active detection rules
- Find rule that generated a specific alert
- Review detection capabilities
- Understand rule logic for tuning

Next Steps:
- Use /secops search-rules to find specific rules by pattern
- Use /secops get-detections to see rule's historical detections
- Use /secops list-errors to check for rule execution issues
{% else %}
Call the list_security_rules tool with: `list_security_rules()`
{% endif %}
"""

# SecOps search_security_rules
[[subCommands]]
name = "search-rules"
description = "Search security detection rules using regex patterns"
prompt = """
{% if help %}
Usage: /secops search-rules [OPTIONS]

Search security detection rules configured in Chronicle SIEM.

Retrieves detection rules that match a regex pattern, allowing you to find
specific rules by content, MITRE techniques, hostnames, or other criteria
coded into the detection logic.

Options:
  --query    Regex string to search for in rules [REQUIRED]
  --help     Show this help message

Examples:
  /secops search-rules --query="TA0005"                    # Find defense evasion rules
  /secops search-rules --query="192.168.1.1"              # Find rules with specific IP
  /secops search-rules --query="WORKSPACE"                 # Find rules using workspace logs
  /secops search-rules --query="powershell.*downloadfile"  # Find PowerShell download rules
  /secops search-rules --query="T1059.001"                 # Find specific MITRE technique

Search Tips:
- Use MITRE ATT&CK technique IDs (T1059.001, TA0005)
- Search for specific hostnames or IP addresses
- Look for log types (WORKSPACE, DNS, PROCESS_LAUNCH)
- Use regex patterns for flexible matching
- Search rule names, descriptions, or YARA-L code

The response includes:
- Matching rule definitions and metadata
- Rule IDs and names
- YARA-L code containing the search pattern
- Rule configuration details

Use Cases:
- Find rules related to specific MITRE techniques
- Locate rules that reference static infrastructure
- Search for rules using specific log types
- Find rules by name or description content

Next Steps:
- Use /secops get-detections to see historical detections
- Use /secops list-errors to check rule execution status
- Use /secops test-rule to validate rule modifications
{% else %}
Call the search_security_rules tool with: `search_security_rules(query={{query}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "query"
  required = true
  description = "Regex string to search for in rules"

# SecOps get_rule_detections
[[subCommands]]
name = "get-detections"
description = "Retrieve historical detections generated by a specific Chronicle SIEM rule"
prompt = """
{% if help %}
Usage: /secops get-detections [OPTIONS]

Retrieve historical detections generated by a specific Chronicle SIEM rule.

Fetches detections based on a rule ID, allowing for investigation and analysis
of rule performance and threat activity. Essential for understanding rule
effectiveness and scoping incident timelines.

Options:
  --rule-id      Unique ID of the rule to get detections for [REQUIRED]
  --alert-state  Filter by alert state (optional)
  --page-size    Maximum detections per response (optional)
  --page-token   Token for pagination (optional)
  --help         Show this help message

Examples:
  /secops get-detections --rule-id="ru_12345678-1234-1234-1234-123456789012"
  /secops get-detections --rule-id="ru_abcdef12-3456-7890-abcd-ef1234567890" --alert-state="ALERTING"
  /secops get-detections --rule-id="ru_87654321@v_12345_67890" --page-size=50

Rule ID Formats:
  ru_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx              # Latest version
  ru_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx@v_12345_67890 # Specific version
  ru_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx@-            # All versions

Alert State Values:
  UNSPECIFIED, NOT_ALERTING, ALERTING

Use Cases:
- Alert triage: Understand rule context and frequency
- Rule effectiveness analysis: Determine if rule is too noisy/quiet
- Threat hunting: Find all instances of specific TTP detection
- Incident scoping: Identify timeline of related events
- Assess alert likelihood of maliciousness

The response includes:
- List of detections with timestamps and details
- Detection metadata and rule information
- Pagination tokens for large result sets
- Related UDM events and indicators

Next Steps:
- Use /secops search-events to find detailed logs for detected events
- Use /secops entity-lookup on indicators found in detections
- Use /secops list-errors if detections are missing or unexpected
{% else %}
Call the get_rule_detections tool with: `get_rule_detections(rule_id={{rule-id}}, alert_state={{alert-state}}, page_size={{page-size}}, page_token={{page-token}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "rule-id"
  required = true
  description = "Unique ID of the rule to get detections for"
  [[subCommands.args]]
  name = "alert-state"
  required = false
  description = "Filter by alert state (UNSPECIFIED, NOT_ALERTING, ALERTING)"
  [[subCommands.args]]
  name = "page-size"
  required = false
  [[subCommands.args]]
  name = "page-token"
  required = false

# SecOps list_rule_errors
[[subCommands]]
name = "list-errors"
description = "List execution errors for a specific Chronicle SIEM rule"
prompt = """
{% if help %}
Usage: /secops list-errors [OPTIONS]

List execution errors for a specific Chronicle SIEM rule.

Helps troubleshoot rules that might not be generating detections as expected
or are failing during execution. Essential for maintaining SIEM operational
health and ensuring rules run correctly.

Options:
  --rule-id  Unique ID of the rule to list errors for [REQUIRED]
  --help     Show this help message

Examples:
  /secops list-errors --rule-id="ru_12345678-1234-1234-1234-123456789012"
  /secops list-errors --rule-id="ru_abcdef12-3456-7890-abcd-ef1234567890@v_12345_67890"
  /secops list-errors --rule-id="ru_87654321-4321-4321-4321-210987654321@-"

Rule ID Formats:
  ru_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx              # Latest version
  ru_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx@v_12345_67890 # Specific version
  ru_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx@-            # All versions

Use Cases:
- Rule troubleshooting: Check why rules aren't producing detections
- Rule development: Verify new/modified rules are running properly
- SIEM health monitoring: Identify rules with execution problems
- Post-deployment validation: Ensure rules work after changes

The response includes:
- Compilation errors and syntax issues
- Runtime execution failures
- Error timestamps and descriptions
- Rule version information

Next Steps:
- Use /secops search-rules to review rule definition and syntax
- Use /secops validate-rule to check syntax after corrections
- Use /secops get-detections to verify rule produces detections after fixes
{% else %}
Call the list_rule_errors tool with: `list_rule_errors(rule_id={{rule-id}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "rule-id"
  required = true
  description = "Unique ID of the rule to list errors for"

# SecOps create_rule
[[subCommands]]
name = "create-rule"
description = "Create a new detection rule in Chronicle SIEM using YARA-L 2.0"
prompt = """
{% if help %}
Usage: /secops create-rule [OPTIONS]

Create a new detection rule in Chronicle SIEM.

Creates a new YARA-L 2.0 detection rule in Chronicle that can generate alerts
when rule conditions are met by ingested events. Rules are the core mechanism
for automated threat detection and response.

Options:
  --rule-text  Complete YARA-L 2.0 rule definition [REQUIRED]
  --help       Show this help message

Examples:
  /secops create-rule --rule-text="rule suspicious_powershell_download {
    meta:
      description = \"Detects PowerShell downloading files\"
      author = \"Security Team\"
      severity = \"Medium\"
      yara_version = \"YL2.0\"
    events:
      \$process.metadata.event_type = \"PROCESS_LAUNCH\"
      \$process.principal.process.command_line = /powershell.*downloadfile/i
    condition:
      \$process
  }"

YARA-L 2.0 Rule Structure:
  rule rule_name {
    meta:               # Rule metadata (description, author, severity, MITRE mappings)
      description = "Rule description"
      author = "Your Name"
      severity = "Low|Medium|High|Critical"
      yara_version = "YL2.0"
      mitre_attack_tactic = "TA0001"
      mitre_attack_technique = "T1059.001"
    events:             # Event matching conditions using UDM fields
      \$event.metadata.event_type = "PROCESS_LAUNCH"
      \$event.principal.hostname != ""
    condition:          # Logic combining events
      \$event
  }

Rule Development Best Practices:
- Start with clear understanding of what to detect
- Use precise conditions to minimize false positives
- Include appropriate metadata (description, author, severity)
- Test thoroughly before deploying to production
- Consider performance impact on Chronicle processing

Use Cases:
- Detect specific attack patterns from threat hunting
- Implement custom detection for proprietary applications
- Create behavioral detection rules for user/entity patterns
- Detect compliance violations or policy breaches
- Implement threat intelligence indicators

Next Steps:
- Use /secops test-rule to validate effectiveness against historical data
- Use /secops validate-rule to check syntax during development
- Use /secops get-detections to monitor rule performance after creation
- Use /secops get-alerts to review generated alerts
{% else %}
Call the create_rule tool with: `create_rule(rule_text={{rule-text}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "rule-text"
  required = true
  description = "Complete YARA-L 2.0 rule definition"

# SecOps test_rule
[[subCommands]]
name = "test-rule"
description = "Test a detection rule against historical data in Chronicle SIEM"
prompt = """
{% if help %}
Usage: /secops test-rule [OPTIONS]

Test a detection rule against historical data in Chronicle SIEM.

Tests a YARA-L 2.0 detection rule against historical data to validate
effectiveness and tune parameters before deployment. Essential for ensuring
rules work as expected and generate appropriate alerts without excessive
false positives.

Options:
  --rule-text     Complete YARA-L 2.0 rule definition to test [REQUIRED]
  --hours-back    How many hours of historical data to test against (default: 168)
  --max-results   Maximum number of detection results to return (default: 100)
  --help          Show this help message

Examples:
  /secops test-rule --rule-text="rule test_network_connection {
    meta:
      description = \"Test rule for network connections\"
      author = \"Security Team\"
      yara_version = \"YL2.0\"
    events:
      \$e.metadata.event_type = \"NETWORK_CONNECTION\"
      \$e.target.port = 443
    condition:
      \$e
  }"

  /secops test-rule --rule-text="..." --hours-back=24 --max-results=50

Rule Testing Best Practices:
- Test against representative time periods (normal + suspicious activity)
- Review detected events to ensure they align with detection objectives
- Adjust rule conditions based on test results to optimize precision
- Consider computational complexity and Chronicle performance impact
- Test with different time windows to understand patterns

The response includes:
- Detection count and analysis summary
- Sample detection details and timestamps
- Rule performance metrics
- Recommendations for rule refinement

Use Cases:
- Validate new rule logic against historical data
- Tune rule thresholds and conditions based on event patterns
- Validate rule modifications before production deployment
- Assess rule performance impact and detection volume
- Compare different rule variations for effectiveness

Next Steps:
- Analyze test results to determine if rule meets detection objectives
- Refine rule based on results and retest as needed
- Use /secops create-rule once testing shows satisfactory results
- Use /secops validate-rule to check syntax during development
{% else %}
Call the test_rule tool with: `test_rule(rule_text={{rule-text}}, hours_back={{hours-back}}, max_results={{max-results}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "rule-text"
  required = true
  description = "Complete YARA-L 2.0 rule definition to test"
  [[subCommands.args]]
  name = "hours-back"
  required = false
  default = "168"
  [[subCommands.args]]
  name = "max-results"
  required = false
  default = "100"

# SecOps validate_rule
[[subCommands]]
name = "validate-rule"
description = "Validate YARA-L 2.0 detection rule syntax in Chronicle SIEM"
prompt = """
{% if help %}
Usage: /secops validate-rule [OPTIONS]

Validate YARA-L 2.0 detection rule syntax in Chronicle SIEM.

Validates the syntax and structure of a YARA-L 2.0 detection rule without
creating or testing it. Useful for checking rule syntax during development
and identifying compilation errors before rule deployment.

Options:
  --rule-text  Complete YARA-L 2.0 rule definition to validate [REQUIRED]
  --help       Show this help message

Examples:
  /secops validate-rule --rule-text="rule example_validation_rule {
    meta:
      description = \"Example rule for validation testing\"
      author = \"Security Team\"
      severity = \"Medium\"
      yara_version = \"YL2.0\"
    events:
      \$e.metadata.event_type = \"NETWORK_CONNECTION\"
      \$e.target.ip != \"\"
      \$e.principal.hostname != \"\"
    condition:
      \$e
  }"

Validation capabilities:
- Syntax validation for YARA-L 2.0 language constructs
- Field name validation against Chronicle's UDM schema
- Function and operator usage validation
- Rule structure and format validation
- Metadata section validation

The response includes:
- Validation success/failure status
- Specific syntax errors with location information
- Suggested fields if available
- Error details for troubleshooting

Use Cases:
- Validate rule syntax during initial development or modification
- Check for compilation errors before committing rule changes
- Quickly verify complex rule logic is syntactically correct
- Validate imported/shared rules before integration
- Educational tool for learning YARA-L 2.0 syntax

Next Steps:
- If validation passes, proceed with /secops test-rule against historical data
- If validation fails, review and correct identified syntax errors
- Use validation feedback to refine rule logic and structure
- Use /secops create-rule once validated and tested
{% else %}
Call the validate_rule tool with: `validate_rule(rule_text={{rule-text}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "rule-text"
  required = true
  description = "Complete YARA-L 2.0 rule definition to validate"

# SecOps get_threat_intel
[[subCommands]]
name = "threat-intel"
description = "Get answers to security questions using Chronicle's integrated Gemini model"
prompt = """
{% if help %}
Usage: /secops threat-intel [OPTIONS]

Get answers to security questions using Chronicle's integrated Gemini model.

Leverages Gemini to answer general security domain questions or provide specific
threat intelligence summaries about threat actors, IOCs, CVEs, TTPs, and other
security topics based on Google's threat intelligence.

Options:
  --query  Security or threat intelligence question to ask Gemini [REQUIRED]
  --help   Show this help message

Examples:
  /secops threat-intel --query="Summarize threat actor APT41"
  /secops threat-intel --query="What is CVE-2024-23897?"
  /secops threat-intel --query="Explain the MITRE ATT&CK technique T1059.001"
  /secops threat-intel --query="What are common persistence mechanisms on Linux?"
  /secops threat-intel --query="Tell me about the LockBit ransomware"
  /secops threat-intel --query="How does the Log4j vulnerability work?"

Question Types:
- Threat Actor Intelligence: "Summarize APT28", "What are Lazarus Group's TTPs?"
- Vulnerability Information: "Explain CVE-2023-44487", "What is the impact of Log4Shell?"
- MITRE ATT&CK Details: "Describe technique T1566.001", "What is tactic TA0008?"
- Malware Analysis: "How does Emotet work?", "What are Cobalt Strike's capabilities?"
- General Security: "What is lateral movement?", "How do DDoS attacks work?"

The response includes:
- Comprehensive threat intelligence summaries
- Technical details and context
- MITRE ATT&CK mappings when relevant
- IOCs and indicators when available
- Recommended defensive measures

Use Cases:
- Quick context during investigations on specific threats/vulnerabilities
- Background information before deeper investigation
- Understanding potential impact of identified CVEs
- Learning about unfamiliar threat actors or malware families
- Getting security concept explanations

Next Steps:
- Use provided intelligence to inform further investigation steps
- Use /secops entity-lookup to check for IOCs in your environment
- Use /secops search-events to find related activity in SIEM logs
- Document relevant findings in case management systems
{% else %}
Call the get_threat_intel tool with: `get_threat_intel(query={{query}})`
{% endif %}
"""
  [[subCommands.args]]
  name = "query"
  required = true
  description = "Security or threat intelligence question to ask Gemini"